# Starter pipeline

# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

# Build Azure Repos Git or TFS Git repositories
# https://learn.microsoft.com/en-us/azure/devops/pipelines/repos/azure-repos-git?view=azure-devops&tabs=yaml#ci-triggers
trigger:
- main
- release*
- feature*
- development

# --------------------------------------------------------------------------------------
# https://learn.microsoft.com/en-us/azure/devops/pipelines/process/service-containers?view=azure-devops&tabs=yaml
# --------------------------------------------------------------------------------------
# https://app.pluralsight.com/course-player?clipId=102ad897-c4ce-436a-8679-e5ba255aa081 
# --------------------------------------------------------------------------------------
# https://app.pluralsight.com/course-player?clipId=31e0c3a1-6211-48d8-9552-5be87fb56e43
# --------------------------------------------------------------------------------------
# Microsoft SQL Server - Ubuntu based images
# https://hub.docker.com/_/microsoft-mssql-server
# --------------------------------------------------------------------------------------
resources:
  containers:
  - container: sqlserver
    image: mcr.microsoft.com/mssql/server:2019-latest
    ports:
      - '1433:1433'
    env:
      MSSQL_SA_PASSWORD: P@ssword1$
      ACCEPT_EULA: Y
  

pool:
  vmImage: ubuntu-latest

# https://learn.microsoft.com/en-us/azure/devops/pipelines/process/service-containers?view=azure-devops&tabs=yaml
services:
  sqlserver: sqlserver
  #redis: redis

variables:
  buildConfiguration: 'Release'
  # --------------------------------------------
  # These variables are going to override the values provided by the file
  # appsettings.test.json of the project BusinessLogic.IntegrationTest
  Database__IntegratedSecurity: "false"
  Database__Server: "sqlserver"
  Database__Port: "1433"
  Database__UserId: "SA"
  Database__Password: "P@ssword1$"  
  # --------------------------------------------

steps:
- script: echo Hello, world!
  displayName: 'Run a one-line script'

- script: |
    echo Add other tasks to build, test, and deploy your project.
    echo See https://aka.ms/yaml
  displayName: 'Run a multi-line script'

- task: Bash@3
  displayName: Print Relevant Variables Values
  inputs:
     targetType: 'inline'
     script: |
       echo "System.Debug=$(System.Debug)"
       echo "Build.Repository.LocalPath=$(Build.Repository.LocalPath)"
  #displayName: Print Variables of imported Variable Groups
  #name: PrintVariableGroupsVariables
  #inputs:
  #    targetType: 'inline'
  #    script: |
  #      echo "System.Debug=$(System.Debug)"
  #      echo "KeyStoreAlias=$(KeyStoreAlias)"
  #      echo "SonarCloudOrganization=$(SonarCloudOrganization)"
  #      echo "SonarCloudProjectKey=$(SonarCloudProjectKey)"
  #      echo "SonarCloudProjectName=$(SonarCloudProjectName)"

- task: NuGetCommand@2
  displayName: 'restore NuGet packages'
  inputs:
    command: 'restore'
    restoreSolution: '**/*.sln'
    feedsToUse: 'select'

- task: DotNetCoreCLI@2
  displayName: 'dotnet build $(buildConfiguration)'
  inputs:
    command: 'build'
    arguments: '--configuration $(buildConfiguration)'
    projects: '**/*.sln'

# --------------------------------------------------------- 
# Run Unit Tests

# Exercise - Perform code coverage testing
# https://learn.microsoft.com/en-us/training/modules/run-quality-tests-build-pipeline/6-perform-code-coverage
# Run Unit Tests in an Azure Pipeline
# https://www.udemy.com/course/azure100/learn/lecture/33318476#overview

# if you want to use test coverage tools in the pipeline you need to let it install the tools
# that are published in the tools MANIFEST file for your solution
- task: DotNetCoreCLI@2
  displayName: 'Install .NET tools from local manifest'
  inputs:
    command: custom
    custom: tool
    arguments: 'restore'

- task: DotNetCoreCLI@2
  displayName: 'Run unit tests - $(buildConfiguration)'
  inputs:
    command: 'test'
    # ------------------------------------------------------------------------
    # This is the minimum that must be done to run the test on the pipeline
    # arguments: '--no-build --configuration $(buildConfiguration)'
    # ------------------------------------------------------------------------
    # If you want to run the test and also the test coverage with the tools
    # then you must provide the right /p: values such as to produce the 
    # test results file of the desired format **coverage.cobertura.xml**, etc.
    arguments: '--no-build --configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/'
    publishTestResults: true
    # ------------------------------------------------------------------------
    # the pattern here is important.
    #projects: '**/*.Test.csproj'
    #..
    projects: '**/*.*Test.csproj'
    # ------------------------------------------------------------------------

# after the test run the coverage.cobertura.xml can be used by the RaptorGenerator tool
# to produce the HtmlInline_AzurePipelines that will be understood and used by the 
# Azure Pipeline reporting and displayed to the Test tab after the run
- task: DotNetCoreCLI@2
  displayName: 'Create code coverage report'
  inputs:
    command: custom
    custom: tool
    arguments: 'run reportgenerator -reports:$(Build.SourcesDirectory)/**/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/CodeCoverage -reporttypes:HtmlInline_AzurePipelines'

# You have to tell Azure Pipelines that you would like the test coverage results 
# in HtmlInline_AzurePipelines to be published to the Test tab at the end of the 
# pipeline run
- task: PublishCodeCoverageResults@1
  displayName: 'Publish code coverage report'
  inputs:
    codeCoverageTool: 'cobertura'
    summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'

# ---------------------------------------------------------
# Publish 

- task: DotNetCoreCLI@2
  displayName: 'dotnet publish $(buildConfiguration)'
  inputs:
    command: 'publish'
    arguments: '--configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)'
    projects: 'WebApp-01/WebApp-01.csproj'
    #arguments: '--configuration $(buildConfiguration) --no-build'
    #zipAfterPublish: true => this is the default and it is important to the PublishPipelineArtifact@1 that follows
    #modifyOutputPath: true # boolean. Optional. Use when command = publish. Add project's folder name to publish path. Default: true.
    
    
# you need to copy the files azuredeploy*.json first because 
# PublishPipelineArtifact@1 cannot use wildcards while 
# CopyFiles@2 can
- task: CopyFiles@2  
  displayName: 'copy files azuredeploy*.json'
  inputs:
    sourceFolder: '$(Build.Repository.LocalPath)/ArmTemplates/bin/Release/'
    contents: 'azuredeploy*.json'
    targetFolder: '$(Pipeline.Workspace)/temparmtemplates/'

- task: PublishPipelineArtifact@1
  displayName: 'publish artifacts arm templates'
  inputs:
    targetPath: '$(Pipeline.Workspace)/temparmtemplates/'
    artifact: 'armtemplates'
    publishLocation: 'pipeline'

# WHEN 
# --output $(Build.ArtifactStagingDirectory) 
# is NOT used as argument to the publish task
# 
# mind that PublishPipelineArtifact@1 relies on the output of a previous 
# DotNetCoreCLI@2 step used to invoke the publish command for the *.csproj
# and this taks has a zipAfterPublish [true] param that causes the publish 
# folder to be zipped by default. This is different from what happens in VS
# REF: https://intellitect.com/blog/missing-publish-directory/
#
# WHEN 
# --output $(Build.ArtifactStagingDirectory) 
# is used as argument to the publish task
# AND
# modifyOutputPath: true
#
# the published task outputs a zipped folder named $(Build.ArtifactStagingDirectory)/projectName.zip 
- task: PublishPipelineArtifact@1
  displayName: 'publish artifacts webapp-01'
  inputs:    
    targetPath: '$(Build.ArtifactStagingDirectory)/WebApp-01.zip'
    #targetPath: '$(Pipeline.Workspace)/s/WebApp-01/bin/Release/net6.0/publish.zip'
    artifact: 'webapp01'
    publishLocation: 'pipeline'
  

